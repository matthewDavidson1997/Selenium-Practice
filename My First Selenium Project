from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.support.ui import Select
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import NoSuchElementException
from selenium.common.exceptions import ElementClickInterceptedException
from seleniumwire import webdriver
from seleniumwire.utils import decode
import pandas as pd
import json
import requests

target_url = "https://www.cambridgeenglish.org/find-a-centre/find-an-exam-centre/"

options = webdriver.ChromeOptions()
options.add_argument("auto-open-devtools-for-tabs")
options.add_argument("start-maximised")
options.add_experimental_option("detach", True)
driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)
driver.get(target_url)
driver.maximize_window()

# Elements we want to interact with and how to find them
location_element_by_id = (By.ID, "location")
search_button_by_class_name = (By.CLASS_NAME, "btn.btn-primary.m-0")
pop_up_close_button_by_class_name = (By.CLASS_NAME, "fancybox-item.fancybox-close")
loading_backdrop_by_class_name = (By.CLASS_NAME, "backdrop")

# Find an element 
def find_element(*element_to_find):
    return (driver.find_element(*element_to_find))

def select_element(element_to_select):
    return Select(element_to_select)

def wait_for_element_to_appear(length, element):
    WebDriverWait(driver, length).until(EC.presence_of_element_located(element))

def wait_for_element_to_disappear(length, element):
    WebDriverWait(driver, length).until_not(EC.presence_of_element_located(element))

def check_for_loading_screen():
    try:
        wait_for_element_to_disappear(10, loading_backdrop_by_class_name)
    except NoSuchElementException:
        pass

def close_pop_up():
    try:
        find_element(*pop_up_close_button_by_class_name).click()
    except NoSuchElementException:
        pass

def iterate_through_location_list():
    # For each country in location list the following steps will be performed

    location_count = len(Select(find_element(*location_element_by_id)).options)
    for index in range(21, 24):
        # Wait for the location element to appear
        wait_for_element_to_appear(length=10, element=location_element_by_id)
        # Select the location element based on the index number
        select_element(find_element(*location_element_by_id)).select_by_index(index)
        # Wait for the search button to appear
        wait_for_element_to_appear(length=30, element=search_button_by_class_name)

        # Attempt to click the search button 
        # Set status of click to false
        clicked = False

        # While the search button remains unclicked check for a loading screen or a pop up and deal with them
        while clicked == False:
            try:
                find_element(*search_button_by_class_name).click()
                clicked = True
                break
            # If the click is intercepted by either the loading screen or pop up these are dealt with
            except ElementClickInterceptedException:
                check_for_loading_screen()
                close_pop_up()

def get_network_responses():
    for request in driver.requests:
        if request.url == "https://apis.cambridgeassessment.org.uk/ce/v1/find-a-centre/centres":
            response = decode(request.response.body, request.response.headers.get('Content-Encoding', 'identity'))
            response = response.decode("utf8")
            json_data = json.loads(response)
            response_as_dataframe = pd.json_normalize(json_data, errors='ignore')
            print(response_as_dataframe)
            response_as_dataframe = response_as_dataframe[['CentreId', 'Name', 'Longitude', 'Latitude']]
            print(response_as_dataframe)

if __name__ == '__main__':
    iterate_through_location_list()
    get_network_responses()

    
